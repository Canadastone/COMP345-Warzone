/*
* Assignment 1 - COMP 345
* Authors: Ariberto Bello Veras, Joshua Bitton, Liam Daigle, 
* Ash Stone, Cyrus Stonebanks, Kirill Vishnyakov
* Date: 2025-10-07
* Description: This file contains the implementation of the map
*/

#include "Map.h"
#include <vector>
#include <string>
#include <iostream>
#include <map>
#include <fstream>
#include <sstream>

//-----------------------------------------------
// Map Functions
//-----------------------------------------------

Map::Map(std::string filePath) {
	MapLoader loader;
	this->territories = loader.generateTerritories(filePath);
	this->adjacencyMatrix = loader.generateConnectedTerritories(filePath, this->territories);
}

void Map::printMap() {

	for (std::pair<std::string, Territory> pair : this->adjacencyMatrix) {
		pair.second.printTerritory();
	}
}

Map::Territory Map::getTerritory(std::string territoryName) {
	if (this->adjacencyMatrix.find(territoryName) != this->adjacencyMatrix.end()) {
		return this->adjacencyMatrix.at(territoryName);
	}
	else {
		std::cout << "Error: \"" << territoryName << "\" is not a valid territory." << std::endl;
	}
}

//-----------------------------------------------
// Territory Functions
//-----------------------------------------------

Map::Territory::Territory() {
	this->numArmies = 0;
}

Map::Territory::Territory(std::string name, std::string continent) {
	this->name = name;
	this->continent = continent;
	this->numArmies = 0;
}

void Map::Territory::addConnection(Territory territory) {
	this->connectedTerritories.push_back(territory);
}

void Map::Territory::setOwnership(std::string owner) {
	this->ownedBy = owner;
}

std::string Map::Territory::getName() {
	return this->name;
}

std::string Map::Territory::getOwnership() {
	return this->ownedBy;
}

void Map::Territory::printTerritory() {

	std::cout << "Territory Name: " << this->name << std::endl;
	std::cout << "Continent: " << this->continent << std::endl;
	std::cout << "Owned by: " << this->ownedBy << std::endl;
	std::cout << "Connected Territories: ";

	for (Territory territory : this->connectedTerritories) {
		std::cout << territory.getName() << ", ";
	}
	std::cout << std::endl;
	std::cout << "---------------------------------------------------------------" << std::endl;
}

//-----------------------------------------------
// MapLoader Functions
//-----------------------------------------------

/**
*
* @brief The function generates a list of the territories used by the map.
*
* This function is the first step in loading our map. It parses through the entire file and creates instances
* of each territory (our nodes). This allows us to be able to reference these instances when creating our adjacency matrix,
* and thus physically connecting these nodes to one another.
*
* @param filePath The path to the file to be read
*
* @return Returns a vector that contains the references to all the territories (our nodes) that will be used by the map.
*/
std::vector < Map::Territory > Map::MapLoader::generateTerritories(std::string filePath) {

	std::vector<Territory> territoriesVector;

	std::ifstream file(filePath);

	std::string text;
	bool startReading = false;

	while (std::getline(file, text)) {

		if (text == "[Territories]") {
			startReading = true;
			continue;
		}

		//If statement that only gets hits if the file has read up to the "[Territories]" string in the file
		if (startReading == true) {

			if (text == "") { //Skip if there is an empty line in the file
				continue;
			}

			std::stringstream textStream(text);
			std::string item;
			char delimiter = ',';
			std::vector<std::string> items;//Indexes each value delimited by a comma into a vector list

			//Adds all values in a row into the items vector
			while (std::getline(textStream, item, delimiter)) {
				items.push_back(item);
			}

			std::string territoryName = items.at(0);
			std::string continentName = items.at(3);

			Territory newTerritory(territoryName, continentName);

			territoriesVector.push_back(newTerritory);
		}
	}

	file.close();

	return territoriesVector;
}

/**
*
* @brief The function connects all the linked territories and returns the adjacency matrix for the map.
*
* This function must only be called after generateTerritories was called, as it relies on the vector that contains the territories.
* The function will parse through the file and find all the territories connected to a current territory, and connect them together.
* Then, it will return a map that represent an adjacency matrix that allows you to easily access each territory by name.
*
* @param filePath The path to the file to be read
* @param generatedTerritories The territory nodes generated by the generateTerritories method
*
* @return Returns a map that represents the adjacency matrix for the map.
*/
std::map<std::string, Map::Territory> Map::MapLoader::generateConnectedTerritories(std::string filePath, std::vector<Territory> generatedTerritories) {

	std::map<std::string, Map::Territory> map;

	std::ifstream file(filePath);

	std::string text;
	bool startReading = false;

	while (std::getline(file, text)) {

		if (text == "[Territories]") {
			startReading = true;
			continue;
		}

		//If statement that only gets hits if the file has read up to the "[Territories]" string in the file
		if (startReading == true) {

			if (text == "") { //Skip if there is an empty line in the file
				continue;
			}

			std::stringstream textStream(text);
			std::string item;
			char delimiter = ',';
			std::vector<std::string> items;//Indexes each value delimited by a comma into a vector of strings

			//Adds all values in a row into the items vector
			while (std::getline(textStream, item, delimiter)) {
				items.push_back(item);
			}

			//Retrieve all connected territories and store them in the connectedTerritories vector
			std::vector<Territory> connectedTerritories;
			for (int i = 4; i < items.size(); i++) {
				std::string territoryName = items.at(i);
				for (Territory territory : generatedTerritories) {
					if (territory.getName() == territoryName) {
						connectedTerritories.push_back(territory);
					}
				}
			}

			//Retrieve the territory name and continent from the row
			std::string territoryName = items.at(0);

			//Retrieve the reference to the current Territory from the already generated list of Territories
			Territory currentTerritory;
			for (Territory territory : generatedTerritories) {
				if (territory.getName() != territoryName) {
					continue;
				}
				currentTerritory = territory;
			}

			//Add the connected territories to the current territory
			for (Territory connectedTerritory : connectedTerritories) {
				currentTerritory.addConnection(connectedTerritory);
			}

			//Insert the territory into the adjacency matrix
			map.insert(std::make_pair(territoryName, currentTerritory));
		}

	}

	file.close();

	return map;
}